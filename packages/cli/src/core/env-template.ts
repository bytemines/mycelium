/**
 * Manages .env.template (git-tracked, keys only) and .env.local (gitignored, with values).
 */
import * as fs from "node:fs/promises";
import * as path from "node:path";
import { expandPath } from "@mycelium/core";
import { readFileIfExists, mkdirp } from "./fs-helpers.js";

const MYCELIUM_DIR = "~/.mycelium";

function parseEnvKeys(content: string): string[] {
  const keys: string[] = [];
  for (const line of content.split("\n")) {
    const trimmed = line.trim();
    if (!trimmed || trimmed.startsWith("#")) continue;
    const eq = trimmed.indexOf("=");
    if (eq === -1) continue;
    const key = trimmed.slice(0, eq).trim();
    if (key) keys.push(key);
  }
  return keys;
}

function parseEnvPairs(content: string): Record<string, string> {
  const result: Record<string, string> = {};
  for (const line of content.split("\n")) {
    const trimmed = line.trim();
    if (!trimmed || trimmed.startsWith("#")) continue;
    const eq = trimmed.indexOf("=");
    if (eq === -1) continue;
    const key = trimmed.slice(0, eq).trim();
    const value = trimmed.slice(eq + 1).trim();
    if (key) result[key] = value;
  }
  return result;
}

/**
 * Scan mcps.yaml for ${VAR} references.
 */
export async function scanMcpsVarRefs(): Promise<string[]> {
  const mcpsPath = expandPath(path.join(MYCELIUM_DIR, "mcps.yaml"));
  const content = await readFileIfExists(mcpsPath);
  if (!content) return [];
  const refs = new Set<string>();
  const re = /\$\{([A-Z_][A-Z0-9_]*)}/g;
  let m: RegExpExecArray | null;
  while ((m = re.exec(content)) !== null) {
    refs.add(m[1]);
  }
  return [...refs];
}

/**
 * Read .env.local, extract keys (strip values), write .env.template.
 * Also includes ${VAR} references from mcps.yaml.
 */
export async function generateEnvTemplate(): Promise<string[]> {
  const dir = expandPath(MYCELIUM_DIR);
  await mkdirp(dir);

  const localContent = await readFileIfExists(path.join(dir, ".env.local"));
  const localKeys = localContent ? parseEnvKeys(localContent) : [];
  const mcpVars = await scanMcpsVarRefs();

  const allKeys = [...new Set([...localKeys, ...mcpVars])];
  allKeys.sort();

  const lines = [
    "# Auto-generated by mycelium â€” lists required env vars",
    "# Fill values in .env.local (never committed)",
    ...allKeys.map((k) => `${k}=`),
    "",
  ];

  await fs.writeFile(path.join(dir, ".env.template"), lines.join("\n"), "utf-8");
  return allKeys;
}

/**
 * Compare .env.template keys vs .env.local keys. Return missing keys.
 */
export async function getMissingEnvVars(): Promise<string[]> {
  const dir = expandPath(MYCELIUM_DIR);
  const templateContent = await readFileIfExists(path.join(dir, ".env.template"));
  const localContent = await readFileIfExists(path.join(dir, ".env.local"));

  if (!templateContent) return [];

  const templateKeys = parseEnvKeys(templateContent);
  const localKeys = new Set(localContent ? parseEnvKeys(localContent) : []);

  return templateKeys.filter((k) => !localKeys.has(k));
}

/**
 * Write/append missing keys to .env.local.
 */
export async function setupEnvVars(answers: Record<string, string>): Promise<void> {
  const dir = expandPath(MYCELIUM_DIR);
  await mkdirp(dir);

  const localPath = path.join(dir, ".env.local");
  const existing = await readFileIfExists(localPath);
  const existingPairs = existing ? parseEnvPairs(existing) : {};

  const merged = { ...existingPairs, ...answers };
  const lines = Object.entries(merged).map(([k, v]) => `${k}=${v}`);

  await fs.writeFile(localPath, lines.join("\n") + "\n", "utf-8");
}

/**
 * Ensure ~/.mycelium/.gitignore contains .env.local and machines/ entries.
 */
export async function ensureGitignore(): Promise<void> {
  const dir = expandPath(MYCELIUM_DIR);
  await mkdirp(dir);

  const gitignorePath = path.join(dir, ".gitignore");
  const content = await readFileIfExists(gitignorePath);

  const required = [".env.local", "machines/"];
  const existingLines = content ? content.split("\n").map((l) => l.trim()) : [];
  const missing = required.filter((entry) => !existingLines.includes(entry));

  if (missing.length === 0) return;

  const append = missing.join("\n") + "\n";
  if (content) {
    const sep = content.endsWith("\n") ? "" : "\n";
    await fs.writeFile(gitignorePath, content + sep + append, "utf-8");
  } else {
    await fs.writeFile(gitignorePath, append, "utf-8");
  }
}
