/**
 * Manifest I/O and YAML serialization helpers for migration
 */
import * as fs from "node:fs/promises";
import * as path from "node:path";

import type {
  ScannedMcp,
  ScannedHook,
  MigrationManifest,
} from "@mycelish/core";

import { readFileIfExists, mkdirp, MYCELIUM_HOME } from "../fs-helpers.js";

const MYCELIUM_DIR = MYCELIUM_HOME;
const MANIFEST_PATH = path.join(MYCELIUM_DIR, "migration-manifest.json");

// ============================================================================
// YAML helpers
// ============================================================================

/** Quote a YAML scalar value if it contains special characters */
export function yamlQuote(val: string): string {
  if (/^[@#{}\[\]&*!|>'"%,`]/.test(val) || /[:#]/.test(val) || val.includes("${") || val === "" || val === "true" || val === "false" || val === "null") {
    return `"${val.replace(/\\/g, "\\\\").replace(/"/g, '\\"')}"`;
  }
  return val;
}

export function serializeMcpsYaml(mcps: ScannedMcp[]): string {
  let yaml = "# Mycelium MCP Configuration\n# Auto-generated by migration\n\n";
  for (const mcp of mcps) {
    yaml += `${mcp.name}:\n`;
    yaml += `  command: ${yamlQuote(mcp.config.command)}\n`;
    if (mcp.config.args && mcp.config.args.length > 0) {
      yaml += `  args:\n`;
      for (const arg of mcp.config.args) {
        yaml += `    - ${yamlQuote(arg)}\n`;
      }
    }
    if (mcp.config.env) {
      yaml += `  env:\n`;
      for (const [key, val] of Object.entries(mcp.config.env)) {
        yaml += `    ${key}: ${yamlQuote(String(val))}\n`;
      }
    }
    yaml += "\n";
  }
  return yaml;
}

export async function writeHooksYaml(hooks: ScannedHook[]): Promise<void> {
  if (hooks.length === 0) return;
  const hooksPath = path.join(MYCELIUM_DIR, "global", "hooks.yaml");
  await mkdirp(path.join(MYCELIUM_DIR, "global"));
  let yaml = "# Mycelium Hooks Configuration\n# Auto-generated by migration\n\n";
  for (const hook of hooks) {
    yaml += `${hook.name.replace(/\//g, "-")}:\n`;
    if (hook.event) yaml += `  event: ${hook.event}\n`;
    if (hook.command) yaml += `  command: ${hook.command}\n`;
    if (hook.matchers?.length) {
      yaml += `  matchers:\n`;
      for (const m of hook.matchers) yaml += `    - ${m}\n`;
    }
    if (hook.timeout) yaml += `  timeout: ${hook.timeout}\n`;
    if (hook.path) yaml += `  path: ${hook.path}\n`;
    yaml += `  source: ${hook.source}\n\n`;
  }
  await fs.writeFile(hooksPath, yaml, "utf-8");
}

// ============================================================================
// Manifest I/O
// ============================================================================

export async function loadManifest(): Promise<MigrationManifest> {
  const content = await readFileIfExists(MANIFEST_PATH);
  if (content) {
    return JSON.parse(content);
  }
  return {
    version: "1.0.0",
    lastMigration: "",
    entries: [],
  };
}

export async function saveManifest(manifest: MigrationManifest): Promise<void> {
  await mkdirp(path.dirname(MANIFEST_PATH));
  await fs.writeFile(MANIFEST_PATH, JSON.stringify(manifest, null, 2), "utf-8");
}
